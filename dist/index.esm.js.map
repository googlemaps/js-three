{"version":3,"file":"index.esm.js","sources":["../src/util.ts","../src/three.ts"],"sourcesContent":["/**\n * Copyright 2021 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { MathUtils, Vector3 } from \"three\";\n// shorthands for math-functions, makes equations more readable\nconst { atan, cos, exp, log, tan, PI } = Math;\nconst { degToRad, radToDeg } = MathUtils;\nexport const EARTH_RADIUS = 6371010.0;\nexport const WORLD_SIZE = Math.PI * EARTH_RADIUS;\n/**\n * Converts any of the supported position formats into the\n * google.maps.LatLngAltitudeLiteral format used for the calculations.\n * @param point\n */\nexport function toLatLngAltitudeLiteral(point) {\n    if (window.google &&\n        google.maps &&\n        (point instanceof google.maps.LatLng ||\n            point instanceof google.maps.LatLngAltitude)) {\n        return { altitude: 0, ...point.toJSON() };\n    }\n    return { altitude: 0, ...point };\n}\n/**\n * Converts latitude and longitude to world space coordinates relative\n * to a reference location with y up.\n */\nexport function latLngToVector3Relative(point, reference, target = new Vector3()) {\n    const [px, py] = latLngToXY(point);\n    const [rx, ry] = latLngToXY(reference);\n    target.set(px - rx, py - ry, 0);\n    // apply the spherical mercator scale-factor for the reference latitude\n    target.multiplyScalar(cos(degToRad(reference.lat)));\n    target.z = point.altitude - reference.altitude;\n    return target;\n}\n/**\n * Converts WGS84 latitude and longitude to (uncorrected) WebMercator meters.\n * (WGS84 --> WebMercator (EPSG:3857))\n */\nexport function latLngToXY(position) {\n    return [\n        EARTH_RADIUS * degToRad(position.lng),\n        EARTH_RADIUS * log(tan(0.25 * PI + 0.5 * degToRad(position.lat))),\n    ];\n}\n/**\n * Converts WebMercator meters to WGS84 latitude/longitude.\n * (WebMercator (EPSG:3857) --> WGS84)\n */\nexport function xyToLatLng(p) {\n    const [x, y] = p;\n    return {\n        lat: radToDeg(PI * 0.5 - 2.0 * atan(exp(-y / EARTH_RADIUS))),\n        lng: radToDeg(x) / EARTH_RADIUS,\n    };\n}\n//# sourceMappingURL=util.js.map","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DirectionalLight, Euler, HemisphereLight, MathUtils, Matrix4, PCFSoftShadowMap, PerspectiveCamera, Quaternion, Raycaster, REVISION, Scene, sRGBEncoding, Vector3, WebGLRenderer, } from \"three\";\nimport { latLngToVector3Relative, toLatLngAltitudeLiteral } from \"./util\";\nconst DEFAULT_UP = new Vector3(0, 0, 1);\n/* eslint-disable @typescript-eslint/no-empty-function */\n/**\n * Add a [three.js](https://threejs.org) scene as a [Google Maps WebGLOverlayView](http://goo.gle/WebGLOverlayView-ref).\n */\nexport class ThreeJSOverlayView {\n    constructor(options = {}) {\n        /** {@inheritDoc ThreeJSOverlayViewOptions.animationMode} */\n        this.animationMode = \"ondemand\";\n        this.rotationArray = new Float32Array(3);\n        this.rotationInverse = new Quaternion();\n        this.projectionMatrixInverse = new Matrix4();\n        this.raycaster = new Raycaster();\n        const { anchor = { lat: 0, lng: 0, altitude: 0 }, upAxis = \"Z\", scene, map, animationMode = \"ondemand\", addDefaultLighting = true, } = options;\n        this.overlay = new google.maps.WebGLOverlayView();\n        this.renderer = null;\n        this.camera = null;\n        this.animationMode = animationMode;\n        this.setAnchor(anchor);\n        this.setUpAxis(upAxis);\n        this.scene = scene ?? new Scene();\n        if (addDefaultLighting)\n            this.initSceneLights();\n        this.overlay.onAdd = this.onAdd.bind(this);\n        this.overlay.onRemove = this.onRemove.bind(this);\n        this.overlay.onContextLost = this.onContextLost.bind(this);\n        this.overlay.onContextRestored = this.onContextRestored.bind(this);\n        this.overlay.onStateUpdate = this.onStateUpdate.bind(this);\n        this.overlay.onDraw = this.onDraw.bind(this);\n        this.camera = new PerspectiveCamera();\n        if (map) {\n            this.setMap(map);\n        }\n    }\n    /**\n     * Sets the anchor-point.\n     * @param anchor\n     */\n    setAnchor(anchor) {\n        this.anchor = toLatLngAltitudeLiteral(anchor);\n    }\n    /**\n     * Sets the axis to use as \"up\" in the scene.\n     * @param axis\n     */\n    setUpAxis(axis) {\n        const upVector = new Vector3(0, 0, 1);\n        if (typeof axis !== \"string\") {\n            upVector.copy(axis);\n        }\n        else {\n            if (axis.toLowerCase() === \"y\") {\n                upVector.set(0, 1, 0);\n            }\n            else if (axis.toLowerCase() !== \"z\") {\n                console.warn(`invalid value '${axis}' specified as upAxis`);\n            }\n        }\n        upVector.normalize();\n        const q = new Quaternion();\n        q.setFromUnitVectors(upVector, DEFAULT_UP);\n        // inverse rotation is needed in latLngAltitudeToVector3()\n        this.rotationInverse.copy(q).invert();\n        // copy to rotationArray for transformer.fromLatLngAltitude()\n        const euler = new Euler().setFromQuaternion(q, \"XYZ\");\n        this.rotationArray[0] = MathUtils.radToDeg(euler.x);\n        this.rotationArray[1] = MathUtils.radToDeg(euler.y);\n        this.rotationArray[2] = MathUtils.radToDeg(euler.z);\n    }\n    // implemetation\n    raycast(p, optionsOrObjects, options = {}) {\n        let objects;\n        if (Array.isArray(optionsOrObjects)) {\n            objects = optionsOrObjects || null;\n        }\n        else {\n            objects = [this.scene];\n            options = { ...optionsOrObjects, recursive: true };\n        }\n        const { updateMatrix = true, recursive = false, raycasterParameters, } = options;\n        // when `raycast()` is called from within the `onBeforeRender()` callback,\n        // the mvp-matrix for this frame has already been computed and stored in\n        // `this.camera.projectionMatrix`.\n        // The mvp-matrix transforms world-space meters to clip-space\n        // coordinates. The inverse matrix created here does the exact opposite\n        // and converts clip-space coordinates to world-space.\n        if (updateMatrix) {\n            this.projectionMatrixInverse.copy(this.camera.projectionMatrix).invert();\n        }\n        // create two points (with different depth) from the mouse-position and\n        // convert them into world-space coordinates to set up the ray.\n        this.raycaster.ray.origin\n            .set(p.x, p.y, 0)\n            .applyMatrix4(this.projectionMatrixInverse);\n        this.raycaster.ray.direction\n            .set(p.x, p.y, 0.5)\n            .applyMatrix4(this.projectionMatrixInverse)\n            .sub(this.raycaster.ray.origin)\n            .normalize();\n        // back up the raycaster parameters\n        const oldRaycasterParams = this.raycaster.params;\n        if (raycasterParameters) {\n            this.raycaster.params = raycasterParameters;\n        }\n        const results = this.raycaster.intersectObjects(objects, recursive);\n        // reset raycaster params to whatever they were before\n        this.raycaster.params = oldRaycasterParams;\n        return results;\n    }\n    onStateUpdate() { }\n    /**\n     * Overwrite this method to fetch or create intermediate data structures\n     * before the overlay is drawn that donâ€™t require immediate access to the\n     * WebGL rendering context.\n     */\n    onAdd() { }\n    /**\n     * Overwrite this method to update your scene just before a new frame is\n     * drawn.\n     */\n    onBeforeDraw() { }\n    /**\n     * This method is called when the overlay is removed from the map with\n     * `overlay.setMap(null)`, and is where you can remove all intermediate\n     * objects created in onAdd.\n     */\n    onRemove() { }\n    /**\n     * Triggers the map to update GL state.\n     */\n    requestStateUpdate() {\n        this.overlay.requestStateUpdate();\n    }\n    /**\n     * Triggers the map to redraw a frame.\n     */\n    requestRedraw() {\n        this.overlay.requestRedraw();\n    }\n    /**\n     * Returns the map the overlay is added to.\n     */\n    getMap() {\n        return this.overlay.getMap();\n    }\n    /**\n     * Adds the overlay to the map.\n     * @param map The map to access the div, model and view state.\n     */\n    setMap(map) {\n        this.overlay.setMap(map);\n    }\n    /**\n     * Adds the given listener function to the given event name. Returns an\n     * identifier for this listener that can be used with\n     * <code>google.maps.event.removeListener</code>.\n     */\n    addListener(eventName, handler) {\n        return this.overlay.addListener(eventName, handler);\n    }\n    /**\n     * This method is called once the rendering context is available. Use it to\n     * initialize or bind any WebGL state such as shaders or buffer objects.\n     * @param options that allow developers to restore the GL context.\n     */\n    onContextRestored({ gl }) {\n        this.renderer = new WebGLRenderer({\n            canvas: gl.canvas,\n            context: gl,\n            ...gl.getContextAttributes(),\n        });\n        this.renderer.autoClear = false;\n        this.renderer.autoClearDepth = false;\n        this.renderer.shadowMap.enabled = true;\n        this.renderer.shadowMap.type = PCFSoftShadowMap;\n        // Since r152, default outputColorSpace is SRGB\n        // Deprecated outputEncoding kept for backwards compatibility\n        if (Number(REVISION) < 152)\n            this.renderer.outputEncoding = sRGBEncoding;\n        const { width, height } = gl.canvas;\n        this.renderer.setViewport(0, 0, width, height);\n    }\n    /**\n     * This method is called when the rendering context is lost for any reason,\n     * and is where you should clean up any pre-existing GL state, since it is\n     * no longer needed.\n     */\n    onContextLost() {\n        if (!this.renderer) {\n            return;\n        }\n        this.renderer.dispose();\n        this.renderer = null;\n    }\n    /**\n     * Implement this method to draw WebGL content directly on the map. Note\n     * that if the overlay needs a new frame drawn then call {@link\n     * ThreeJSOverlayView.requestRedraw}.\n     * @param options that allow developers to render content to an associated\n     *     Google basemap.\n     */\n    onDraw({ gl, transformer }) {\n        this.camera.projectionMatrix.fromArray(transformer.fromLatLngAltitude(this.anchor, this.rotationArray));\n        gl.disable(gl.SCISSOR_TEST);\n        this.onBeforeDraw();\n        this.renderer.render(this.scene, this.camera);\n        this.renderer.resetState();\n        if (this.animationMode === \"always\")\n            this.requestRedraw();\n    }\n    /**\n     * Convert coordinates from WGS84 Latitude Longitude to world-space\n     * coordinates while taking the origin and orientation into account.\n     */\n    latLngAltitudeToVector3(position, target = new Vector3()) {\n        latLngToVector3Relative(toLatLngAltitudeLiteral(position), this.anchor, target);\n        target.applyQuaternion(this.rotationInverse);\n        return target;\n    }\n    // MVCObject interface forwarded to the overlay\n    /**\n     * Binds a View to a Model.\n     */\n    bindTo(key, target, targetKey, noNotify) {\n        this.overlay.bindTo(key, target, targetKey, noNotify);\n    }\n    /**\n     * Gets a value.\n     */\n    get(key) {\n        return this.overlay.get(key);\n    }\n    /**\n     * Notify all observers of a change on this property. This notifies both\n     * objects that are bound to the object's property as well as the object\n     * that it is bound to.\n     */\n    notify(key) {\n        this.overlay.notify(key);\n    }\n    /**\n     * Sets a value.\n     */\n    set(key, value) {\n        this.overlay.set(key, value);\n    }\n    /**\n     * Sets a collection of key-value pairs.\n     */\n    setValues(values) {\n        this.overlay.setValues(values);\n    }\n    /**\n     * Removes a binding. Unbinding will set the unbound property to the current\n     * value. The object will not be notified, as the value has not changed.\n     */\n    unbind(key) {\n        this.overlay.unbind(key);\n    }\n    /**\n     * Removes all bindings.\n     */\n    unbindAll() {\n        this.overlay.unbindAll();\n    }\n    /**\n     * Creates lights (directional and hemisphere light) to illuminate the model\n     * (roughly approximates the lighting of buildings in maps)\n     */\n    initSceneLights() {\n        const hemiLight = new HemisphereLight(0xffffff, 0x444444, 1);\n        hemiLight.position.set(0, -0.2, 1).normalize();\n        const dirLight = new DirectionalLight(0xffffff);\n        dirLight.position.set(0, 10, 100);\n        this.scene.add(hemiLight, dirLight);\n    }\n}\n//# sourceMappingURL=three.js.map"],"names":["atan","cos","exp","log","tan","PI","Math","degToRad","radToDeg","MathUtils","EARTH_RADIUS","WORLD_SIZE","toLatLngAltitudeLiteral","point","window","google","maps","LatLng","LatLngAltitude","altitude","toJSON","latLngToVector3Relative","reference","target","Vector3","px","py","latLngToXY","rx","ry","set","multiplyScalar","lat","z","position","lng","xyToLatLng","p","x","y","DEFAULT_UP","ThreeJSOverlayView","constructor","options","this","animationMode","rotationArray","Float32Array","rotationInverse","Quaternion","projectionMatrixInverse","Matrix4","raycaster","Raycaster","anchor","upAxis","scene","map","addDefaultLighting","overlay","WebGLOverlayView","renderer","camera","setAnchor","setUpAxis","Scene","initSceneLights","onAdd","bind","onRemove","onContextLost","onContextRestored","onStateUpdate","onDraw","PerspectiveCamera","setMap","axis","upVector","copy","toLowerCase","console","warn","normalize","q","setFromUnitVectors","invert","euler","Euler","setFromQuaternion","raycast","optionsOrObjects","objects","Array","isArray","recursive","updateMatrix","raycasterParameters","projectionMatrix","ray","origin","applyMatrix4","direction","sub","oldRaycasterParams","params","results","intersectObjects","onBeforeDraw","requestStateUpdate","requestRedraw","getMap","addListener","eventName","handler","gl","WebGLRenderer","canvas","context","getContextAttributes","autoClear","autoClearDepth","shadowMap","enabled","type","PCFSoftShadowMap","Number","REVISION","outputEncoding","sRGBEncoding","width","height","setViewport","dispose","transformer","fromArray","fromLatLngAltitude","disable","SCISSOR_TEST","render","resetState","latLngAltitudeToVector3","applyQuaternion","bindTo","key","targetKey","noNotify","get","notify","value","setValues","values","unbind","unbindAll","hemiLight","HemisphereLight","dirLight","DirectionalLight","add"],"mappings":"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"}